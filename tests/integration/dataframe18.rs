// Test case that compares a file generated by polars_excel_writer with a file
// created by Excel.
//
// SPDX-License-Identifier: MIT OR Apache-2.0
//
// Copyright 2022-2025, John McNamara, jmcnamara@cpan.org

use crate::common;

use chrono::{NaiveDate, NaiveTime};
use polars::prelude::*;
use polars_excel_writer::PolarsXlsxWriter;
use rust_xlsxwriter::{Format, XlsxError};

// Compare output against target Excel file using ExcelWriter.

// The test case uses numbers and formats instead of dates/times.
fn create_new_xlsx_file_1(filename: &str) -> Result<(), XlsxError> {
    let df: DataFrame = df!(
        "Column1" => &[45658.5, 45658.5, 45658.5],
        "Column2" => &[45658.0, 45658.0, 45658.],
        "Column3" => &[0.5, 0.5, 0.5],
    )?;

    let mut xlsx_writer = PolarsXlsxWriter::new();
    let format1 = Format::new().set_num_format("yyyy/mm/dd\\ hh:mm");
    let format2 = Format::new().set_num_format("yyyy/mm/dd");
    let format3 = Format::new().set_num_format("hh\\ mm");

    xlsx_writer.set_column_format("Column1", &format1);
    xlsx_writer.set_column_format("Column2", &format2);
    xlsx_writer.set_column_format("Column3", &format3);

    xlsx_writer.write_dataframe(&df)?;

    let worksheet = xlsx_writer.worksheet()?;
    worksheet.set_column_range_width_pixels(0, 2, 120)?;

    xlsx_writer.save(filename)?;

    Ok(())
}

// The test case uses dates/times.
fn create_new_xlsx_file_2(filename: &str) -> Result<(), XlsxError> {
    let df: DataFrame = df!(

        "Column1" => &[
            NaiveDate::from_ymd_opt(2025, 1, 1).unwrap().and_hms_opt(12, 0, 0).unwrap(),
            NaiveDate::from_ymd_opt(2025, 1, 1).unwrap().and_hms_opt(12, 0, 0).unwrap(),
            NaiveDate::from_ymd_opt(2025, 1, 1).unwrap().and_hms_opt(12, 0, 0).unwrap(),
        ],
        "Column2" => &[
            NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),
            NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),
            NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),
        ],
        "Column3" => &[
            NaiveTime::from_hms_opt(12, 0, 0).unwrap(),
            NaiveTime::from_hms_opt(12, 0, 0).unwrap(),
            NaiveTime::from_hms_opt(12, 0, 0).unwrap(),
        ],
    )?;

    let mut xlsx_writer = PolarsXlsxWriter::new();
    let format1 = Format::new().set_num_format("yyyy/mm/dd\\ hh:mm");
    let format2 = Format::new().set_num_format("yyyy/mm/dd");
    let format3 = Format::new().set_num_format("hh\\ mm");

    xlsx_writer.set_dtype_format(DataType::Datetime(TimeUnit::Milliseconds, None), &format1);
    xlsx_writer.set_dtype_format(DataType::Date, &format2);
    xlsx_writer.set_dtype_format(DataType::Time, &format3);

    xlsx_writer.write_dataframe(&df)?;

    let worksheet = xlsx_writer.worksheet()?;
    worksheet.set_column_range_width_pixels(0, 2, 120)?;

    xlsx_writer.save(filename)?;

    Ok(())
}

#[test]
fn dataframe_excelwriter18_1() {
    let test_runner = common::TestRunner::new()
        .set_name("dataframe18")
        .set_function(create_new_xlsx_file_1)
        .unique("1")
        .initialize();

    test_runner.assert_eq();
    test_runner.cleanup();
}

#[test]
fn dataframe_excelwriter18_2() {
    let test_runner = common::TestRunner::new()
        .set_name("dataframe18")
        .set_function(create_new_xlsx_file_2)
        .unique("2")
        .initialize();

    test_runner.assert_eq();
    test_runner.cleanup();
}
